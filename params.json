{"name":"Solvent","tagline":"Dependency Resolver written in rust","body":"# solvent\r\nSolvent is a dependency resolver library written in rust.\r\n\r\n[![Build Status](https://travis-ci.org/mikedilger/solvent.svg?branch=master)](https://travis-ci.org/mikedilger/solvent)\r\n\r\nSolvent helps you to resolve dependency orderings by building up a dependency\r\ngraph and then resolving the dependences of some target node in an order such\r\nthat each output depends only upon the previous outputs.\r\n\r\nIt is currently quite simple, but is still useful.\r\n\r\n## Example\r\n\r\n```rust\r\nextern crate solvent;\r\n\r\nuse solvent::DepGraph;\r\n\r\nfn main() {\r\n    // Create a new empty DepGraph.  Must be `mut` or else it cannot\r\n    // be used by the rest of the library.\r\n    let mut depgraph: DepGraph = DepGraph::new();\r\n\r\n    // You can register a dependency like this.  Solvent will\r\n    // automatically create nodes for any term it has not seen before.\r\n    // This means 'b' depends on 'd'\r\n    depgraph.register_dependency(\"b\",\"d\");\r\n\r\n    // You can also register multiple dependencies at once\r\n    depgraph.register_dependencies(\"a\",&[\"b\",\"c\",\"d\"]);\r\n    depgraph.register_dependencies(\"c\",&[\"e\"]);\r\n\r\n    // Iterate through each dependency of \"a\".  The dependencies will be\r\n    // returned in an order such that each output only depends on the\r\n    // previous outputs (or nothing).  The target itself will be output\r\n    // last.\r\n    for node in depgraph.dependencies_of(\"a\") {\r\n        print!(\"{} \", node.unwrap());\r\n    }\r\n}\r\n```\r\n\r\nThe above will output:  `d b e c a` or `e c d b a` or some other valid\r\ndependency order.\r\n\r\nThe algorithm is not deterministic, and may give a different answer each\r\ntime it is run.  Beware.\r\n\r\nThe iterator dependencies_of() returns an `Option&lt;Result&lt;String,SolventError&gt;&gt;`.\r\nThe for loop handles the Option part for you, but you may want to check the\r\nresult for SolventErrors.  Once an error is returned, all subsequent calls to\r\nthe iterator next() will yield None.\r\n\r\nYou can also mark some elements as already satisfied, and the iterator\r\nwill take that into account:\r\n\r\n```ignore\r\ndepgraph.mark_as_satisfied([\"e\",\"c\"]);\r\n```\r\n\r\nDependency cycles are detected and will return SolventError::CycleDetected.\r\n\r\n## Use Cases\r\nThese kinds of calculations are useful in the following example situations:\r\n* System package management: packages depending on other packages\r\n* Build systems such as 'make' or 'cargo' to handle dependencies\r\n  (note: neither cargo nor rustc use solvent)\r\n* Complex software configurations such as Linux kernel configurations\r\n* Database schema upgrades which don't need to be strictly sequential\r\n  (e.g. multiple developers working on separate git branches being able\r\n  to commit database schema upgrades independently, without merge\r\n  conflicts) -- the author wrote solvent for this purpose.\r\n\r\n## Other Details\r\nWhile elements (nodes) are registered as slices (&amp;str) and slices of\r\nslices (&amp;[&amp;str]), these borrows do not persist beyond the lifetime of\r\nthe register function call, as they are internally copied into Strings\r\nand Vecs (and HashMaps).\r\n\r\nSolvent does not yet handle boolean logic.  See issue [#1](https://github.com/mikedilger/solvent/issues/1).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}