<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Solvent by mikedilger</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Solvent</h1>
          <h2>Dependency Resolver written in rust</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/mikedilger/solvent/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/mikedilger/solvent/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/mikedilger/solvent" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="solvent" class="anchor" href="#solvent" aria-hidden="true"><span class="octicon octicon-link"></span></a>solvent</h1>

<p>Solvent is a dependency resolver library written in rust.</p>

<p><a href="https://travis-ci.org/mikedilger/solvent"><img src="https://travis-ci.org/mikedilger/solvent.svg?branch=master" alt="Build Status"></a></p>

<p>Solvent helps you to resolve dependency orderings by building up a dependency
graph and then resolving the dependences of some target node in an order such
that each output depends only upon the previous outputs.</p>

<p>It is currently quite simple, but is still useful.</p>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h2>

<div class="highlight highlight-rust"><pre><span class="pl-k">extern crate</span> <span class="pl-s3">solvent</span><span class="pl-k">;</span>

<span class="pl-k">use</span> solvent::DepGraph<span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-c">// Create a new empty DepGraph.  Must be `mut` or else it cannot</span>
    <span class="pl-c">// be used by the rest of the library.</span>
    <span class="pl-k">let</span> <span class="pl-k">mut </span><span class="pl-vo">depgraph</span><span class="pl-st">: DepGraph </span><span class="pl-k">=</span> DepGraph::<span class="pl-s3">new</span>()<span class="pl-k">;</span>

    <span class="pl-c">// You can register a dependency like this.  Solvent will</span>
    <span class="pl-c">// automatically create nodes for any term it has not seen before.</span>
    <span class="pl-c">// This means 'b' depends on 'd'</span>
    depgraph<span class="pl-k">.</span><span class="pl-s3">register_dependency</span>(<span class="pl-s1">"b"</span><span class="pl-k">,</span><span class="pl-s1">"d"</span>)<span class="pl-k">;</span>

    <span class="pl-c">// You can also register multiple dependencies at once</span>
    depgraph<span class="pl-k">.</span><span class="pl-s3">register_dependencies</span>(<span class="pl-s1">"a"</span><span class="pl-k">,&amp;</span>[<span class="pl-s1">"b"</span><span class="pl-k">,</span><span class="pl-s1">"c"</span><span class="pl-k">,</span><span class="pl-s1">"d"</span>])<span class="pl-k">;</span>
    depgraph<span class="pl-k">.</span><span class="pl-s3">register_dependencies</span>(<span class="pl-s1">"c"</span><span class="pl-k">,&amp;</span>[<span class="pl-s1">"e"</span>])<span class="pl-k">;</span>

    <span class="pl-c">// Iterate through each dependency of "a".  The dependencies will be</span>
    <span class="pl-c">// returned in an order such that each output only depends on the</span>
    <span class="pl-c">// previous outputs (or nothing).  The target itself will be output</span>
    <span class="pl-c">// last.</span>
    <span class="pl-k">for</span> node <span class="pl-k">in</span> depgraph<span class="pl-k">.</span><span class="pl-s3">dependencies_of</span>(<span class="pl-s1">"a"</span>) {
        print!(<span class="pl-s1">"{} "</span><span class="pl-k">,</span> node<span class="pl-k">.</span><span class="pl-s3">unwrap</span>())<span class="pl-k">;</span>
    }
}</pre></div>

<p>The above will output:  <code>d b e c a</code> or <code>e c d b a</code> or some other valid
dependency order.</p>

<p>The algorithm is not deterministic, and may give a different answer each
time it is run.  Beware.</p>

<p>The iterator dependencies_of() returns an <code>Option&amp;lt;Result&amp;lt;String,SolventError&amp;gt;&amp;gt;</code>.
The for loop handles the Option part for you, but you may want to check the
result for SolventErrors.  Once an error is returned, all subsequent calls to
the iterator next() will yield None.</p>

<p>You can also mark some elements as already satisfied, and the iterator
will take that into account:</p>

<pre lang="ignore"><code>depgraph.mark_as_satisfied(["e","c"]);
</code></pre>

<p>Dependency cycles are detected and will return SolventError::CycleDetected.</p>

<h2>
<a id="use-cases" class="anchor" href="#use-cases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Use Cases</h2>

<p>These kinds of calculations are useful in the following example situations:</p>

<ul>
<li>System package management: packages depending on other packages</li>
<li>Build systems such as 'make' or 'cargo' to handle dependencies
(note: neither cargo nor rustc use solvent)</li>
<li>Complex software configurations such as Linux kernel configurations</li>
<li>Database schema upgrades which don't need to be strictly sequential
(e.g. multiple developers working on separate git branches being able
to commit database schema upgrades independently, without merge
conflicts) -- the author wrote solvent for this purpose.</li>
</ul>

<h2>
<a id="other-details" class="anchor" href="#other-details" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Details</h2>

<p>While elements (nodes) are registered as slices (&amp;str) and slices of
slices (&amp;[&amp;str]), these borrows do not persist beyond the lifetime of
the register function call, as they are internally copied into Strings
and Vecs (and HashMaps).</p>

<p>Solvent does not yet handle boolean logic.  See issue <a href="https://github.com/mikedilger/solvent/issues/1">#1</a>.</p>
        </section>

        <footer>
          Solvent is maintained by <a href="https://github.com/mikedilger">mikedilger</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>